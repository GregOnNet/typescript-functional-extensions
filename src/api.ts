import { ResultAsync } from './resultAsync.js';
import { AsyncFunctionOfTtoK, FunctionOfTtoK, Some } from './utilities.js';

/**
 * Wraps a fetch request generated Promise in a ResultAsync,
 * ensuring both connection errors and Http status code errors
 * are converted into failed Results.
 * The JSON response is unwrapped as object type specified by TValue. Use this for JSON responses.
 * @param request A Promise<Response> generated by a fetch() request
 * @param errorHandler Handles connection and Http status code errors. Can be asynchronous to enable evaluation of the Response body.
 * @returns ResultAsync representing the success/failure of the request
 */
export function fetchJsonResponse<TValue, TError = string>(
  request: Promise<Response>,
  errorHandler:
    | FunctionOfTtoK<unknown, Some<TError>>
    | AsyncFunctionOfTtoK<unknown, Some<TError>>
): ResultAsync<TValue, TError> {
  return ResultAsync.try<Response, TError>(request, errorHandler)
    .ensure((resp) => resp.ok, errorHandler)
    .map<TValue>((resp) => resp.json());
}

/**
 * Wraps a fetch request generated Promise in a ResultAsync,
 * ensuring both connection errors and Http status code errors
 * are converted into failed Results.
 * The raw Response object is returned as the Result success value.
 * @param request A Promise<Response> generated by a fetch() request
 * @param errorHandler Handles connection and Http status code errors. Can be asynchronous to enable evaluation of the Response body.
 * @returns ResultAsync representing the success/failure of the request
 */
export function fetchResponse<TError = string>(
  request: Promise<Response>,
  errorHandler:
    | FunctionOfTtoK<unknown, Some<TError>>
    | AsyncFunctionOfTtoK<unknown, Some<TError>>
): ResultAsync<Response, TError> {
  return ResultAsync.try<Response, TError>(request, errorHandler).ensure(
    (resp) => resp.ok,
    errorHandler
  );
}
